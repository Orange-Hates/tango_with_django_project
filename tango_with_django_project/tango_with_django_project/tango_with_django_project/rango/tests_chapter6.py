# Tango with Django 2 Progress Tests
# By Leif Azzopardi and David Maxwell
# With assistance from Enzo Roiz (https://github.com/enzoroiz)
#
# Chapter 6 -- Models, Templates and Views
# Last updated: October 15th, 2019
# Revising Author: David Maxwell
#

#
# In order to run these tests, copy this module to your tango_with_django_project/rango/ directory.
# Once this is complete, run $ python manage.py test rango.tests_chapter6
#
# The tests will then be run, and the output displayed -- do you pass them all?
#
# Once you are done with the tests, delete the module. You don't need to put it in your Git repository!
#

import os
import re  # We use regular expressions to do more in-depth checks on generated HTML output from views.
import importlib
from rango.models import Category, Page
from populate_rango import populate
from django.urls import reverse
from django.test import TestCase
from django.db.models.query import QuerySet

FAILURE_HEADER = f"{os.linesep}{os.linesep}{os.linesep}================{os.linesep}TwD TEST FAILURE =({os.linesep}================{os.linesep}"
FAILURE_FOOTER = f"{os.linesep}"


class Chapter6PopulationScriptTest(TestCase):
    """
    A few simple tests to examine whether the population script has been updated to include the requested changes (views for pages).
    """
    def setUp(self):
        populate()

    def test_page_objects_have_views(self):
        """
        Checks the basic requirement that all pages must have a positive view count.
        """
        pages = Page.objects.filter()
        for page in pages:
            self.assertTrue(
                page.views > 0,
                f"{FAILURE_HEADER}The page '{page.title}' has zero or negative views. Update populate_rango.py.{FAILURE_FOOTER}"
            )


class Chapter6IndexViewTests(TestCase):
    """
    A series of tests that examine the behaviour of the index view and its corresponding template.
    Tests to see if the context dictionary is correctly formed, and whether the response is correct.
    """
    def setUp(self):
        populate()
        self.response = self.client.get(reverse('rango:index'))
        self.content = self.response.content.decode()

    def test_template_filename(self):
        """
        Still using a template?
        """
        self.assertTemplateUsed(
            self.response, 'rango/index.html',
            f"{FAILURE_HEADER}Are you using index.html for the index() view?{FAILURE_FOOTER}"
        )

    def test_index_context_dictionary(self):
        """
        Runs some assertions to check if the context dictionary has the correct key/value pairings.
        """
        expected_boldmessage = 'Crunchy, creamy, cookie, candy, cupcake!'
        expected_categories = list(Category.objects.order_by('-likes')[:5])
        expected_pages = list(Page.objects.order_by('-views')[:5])

        self.assertTrue('boldmessage' in self.response.context)
        self.assertEqual(expected_boldmessage, self.response.context['boldmessage'])

        self.assertTrue('categories' in self.response.context)
        self.assertEqual(type(self.response.context['categories']), QuerySet)
        self.assertEqual(expected_categories, list(self.response.context['categories']))

        self.assertTrue('pages' in self.response.context)
        self.assertEqual(type(self.response.context['pages']), QuerySet)
        self.assertEqual(expected_pages, list(self.response.context['pages']))

    def test_index_categories(self):
        """
        Checks the response generated by the index() view -- does it render the categories correctly?
        """
        category_regexes = [
            (r'<li>\s*<a\s+href="/rango/category/python/">Python</a>\s*</li>', 'Python'),
            (r'<li>\s*<a\s+href="/rango/category/django/">Django</a>\s*</li>', 'Django'),
            (r'<li>\s*<a\s+href="/rango/category/other-frameworks/">Other Frameworks</a>\s*</li>', 'Other Frameworks'),
        ]

        for regex, name in category_regexes:
            self.assertTrue(re.search(regex, self.content),
                            f"{FAILURE_HEADER}Missing link for {name} category in index.html.{FAILURE_FOOTER}")

    def test_index_pages(self):
        """
        Checks the response generated by the index() view -- does it render the pages correctly?
        """
        page_regexes = {
            'Official Python Tutorial': r'<li>\s*<a\s+href="http://docs.python.org/3/tutorial/">Official Python Tutorial</a>\s*\(\d+ views\)\s*</li>',
            'How to Think like a Computer Scientist': r'<li>\s*<a\s+href="http://www.greenteapress.com/thinkpython/">How to Think like a Computer Scientist</a>\s*\(\d+ views\)\s*</li>',
            'Learn Python in 10 Minutes': r'<li>\s*<a\s+href="http://www.korokithakis.net/tutorials/python/">Learn Python in 10 Minutes</a>\s*\(\d+ views\)\s*</li>',
            'Official Django Tutorial': r'<li>\s*<a\s+href="https://docs.djangoproject.com/en/2.1/intro/tutorial01/">Official Django Tutorial</a>\s*\(\d+ views\)\s*</li>',
            'Django Rocks': r'<li>\s*<a\s+href="http://www.djangorocks.com/">Django Rocks</a>\s*\(\d+ views\)\s*</li>',
        }

        expected_pages = list(Page.objects.order_by('-views')[:5])
        for page in expected_pages:
            regex = page_regexes.get(page.title, None)
            if regex:
                self.assertTrue(re.search(regex, self.content),
                                f"{FAILURE_HEADER}Incorrect page list markup in index.html.{FAILURE_FOOTER}")

    def test_index_response_titles(self):
        """
        Checks whether the correct titles are used (including <h2> tags) for categories and pages.
        """
        self.assertIn('<h2>Most Liked Categories</h2>', self.content)
        self.assertIn('<h2>Most Viewed Pages</h2>', self.content)


class Chapter6CategoryViewTests(TestCase):
    """
    Tests for the show_category view and template.
    """
    def setUp(self):
        populate()
        self.response = self.client.get(
            reverse('rango:show_category', kwargs={'category_name_slug': 'other-frameworks'}))
        self.content = self.response.content.decode()

    def test_template_filename(self):
        """
        Still using a template?
        """
        self.assertTemplateUsed(self.response, 'rango/category.html')

    def test_context_dictionary(self):
        """
        Given the response, does the context dictionary match up with what is expected?
        """
        category = Category.objects.get(name='Other Frameworks')
        expected_pages = list(Page.objects.filter(category=category).order_by('-views'))  # FIXED ORDERING

        self.assertEqual(self.response.context['category'], category)
        self.assertEqual(list(self.response.context['pages']), expected_pages)

    def test_for_homepage_link(self):
        """
        Checks to see if a hyperlink to the homepage is present.
        """
        self.assertTrue(re.search(r'<a\s+href="/rango/">Home</a>', self.content),
                        "We couldn't find a well-formed hyperlink to the Rango homepage in your category.html template.")


class Chapter6BadCategoryViewTests(TestCase):
    """
    Tests for handling non-existent categories.
    """
    def test_malformed_url(self):
        """
        Tests to see whether the URL patterns have been correctly entered.
        """
        response = self.client.get('/rango/category/')
        self.assertEqual(response.status_code, 404)

    def test_nonexistent_category(self):
        """
        Attempts to lookup a category that does not exist in the database and checks the response.
        """
        response = self.client.get(reverse('rango:show_category', kwargs={'category_name_slug': 'nonexistent'}))
        self.assertIn('The specified category does not exist.', response.content.decode())

    def test_empty_category(self):
        """
        Adds a Category without pages; checks to see what the response is.
        """
        Category.objects.create(name='Empty Category')
        response = self.client.get(reverse('rango:show_category', kwargs={'category_name_slug': 'empty-category'}))
        self.assertIn('<strong>No pages currently in category.</strong>', response.content.decode())
